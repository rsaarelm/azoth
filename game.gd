extends Node

## Cached current area.
## Do not set from outside Game.
var _area: Area = null

## State variable for abilities being aimed.
var aim_ability: Ability = null:
	set(value):
		get_tree().current_scene.aim_ability = value

#region Static game-specific functions

## Distance between two games in the metric used by the game.
static func dist(p1, p2) -> float:
	# Taxicab metric distance
	p1 = Util.unwrap_cell(p1)
	p2 = Util.unwrap_cell(p2)
	return abs(p1.x - p2.x) + abs(p1.y - p2.y)

## How many coins do you need to pay to level up to given level.
static func level_up_cost(level: int) -> int:
	return int(100 * 1.05 ** (level - 1))

#endregion

#region Global time and state management

var is_paused := true

## Toggle variable for pausing, we want actual pause switch to happen at
## Game._process and nowhere else to control when the other _process calls see
## the game as running.
var pause_requested = null

func _process(delta: float) -> void:
	if !is_paused:
		# Unless the leader is doing a long move, pause a running game right
		# again.
		if leader() and !leader().has_goal():
			is_paused = true

	# Always listen to toggling the pause. If the player isn't acting, the
	# toggle serves as a "pass turn" command.
	if Input.is_action_just_pressed("toggle_pause") and pause_requested == null:
		is_paused = !is_paused

	# Apply deferred pause request.
	match pause_requested:
		null:
			# No change requested
			pass
		true:
			is_paused = true
			pause_requested = null
		false:
			is_paused = false
			pause_requested = null

## Start running logic after player turn
func start_running():
	pause_requested = false

## Start running logic after player turn
func stop_running():
	pause_requested = true

## Reset levels and respawn player to last checkpoint.
##
## If `retain_player` is true, the player's injuries and status effects are
## sustained.
func restart_world(retain_player=false):
	var player: Mob = null
	# Keep original player mob around
	if retain_player:
		player = Player.mob()
		assert(player)
		# Detach player mob from world.
		player.get_parent().remove_child(player)

	# Restarting is baked into GameScreen's initialization routine, so we just
	# reload the scene here.
	get_tree().change_scene_to_file("res://game_screen.tscn")

	if retain_player and player:
		# Remove the fresh player generated by scene change.
		var dummy_player = Player.mob()

		# Put retained player in its place.
		player.cell = dummy_player.cell
		dummy_player.get_parent().add(player)
		dummy_player.queue_free()

func player_died():
	await get_tree().create_timer(0.4).timeout
	get_tree().change_scene_to_file("res://you_died.tscn")
	await get_tree().create_timer(1.0).timeout
	# Restarting is baked into GameScreen's initialization routine, so we just
	# reload the scene here. This will respawn player at the last respawn
	# position.
	get_tree().change_scene_to_file("res://game_screen.tscn")

## Load a new area and place the player in the given pos.
##
## If player is unspecified, pull out the existing player.
func load_area(scene_path: String, player_pos: Vector2i, player: Mob = null):
	if not player:
		# Get existing player entity.
		player = Player.mob()
		assert(player)

	# If player is in a container, detach it from that first.
	if player.get_parent():
		player.get_parent().remove_child(player)

	var view = get_tree().current_scene.find_child("GameView", true, false)
	assert(view, "XXX: load_area assumes it's in GameView")

	# Remove existing area if there is one.
	for child in view.get_children():
		child.queue_free()

	# Load the new area
	_area = load(scene_path).instantiate()
	view.add_child(_area)

	# Add player
	player.cell = player_pos
	_area.add_child(player)
#endregion

func msg(text: String) -> void:
	get_tree().current_scene.msg(text)

## Get the current leader mob (directly controlled player character).
## This may be different than the main player character if a minion NPC
## is temporarily assigned to lead the team.
func leader() -> Mob:
	return Player.mob()

func area() -> Area:
	return _area
